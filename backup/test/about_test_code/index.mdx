---
title: '테스트코드에 대해서 깊게 이해하기'
image: '/frontEnd/test/about_test_code/index.webp'
description: 'Unit Test가 중요하다는 이야기를 많이 들었지만, 제대로 이해하지 못했었습니다. 그러다, 리팩토링 과정에서 테스트 코드의 중요성을 꺠닫게 되었고, 이번 기회에 제대로 이해해보자는 생각에 Vitest를 바탕으로 유닛 테스트를 톺아보기로 했습니다.'
tags: [frontEnd, test]
keywords: ['Frontend', 'test', 'vitest', 'jest', 'unit test']
sidebar_position: 1
sidebar_label: '테스트코드에 대해서 깊게 이해하기'
sidebar_custom_props:
  img: '/frontEnd/test/about_test_code/index.webp'
last_update:
  date: 2025-02-03
---

import { Figure, VideoPlayer } from '@site/src/components/utils';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## 배경

<Figure fileName="voyage.webp" alt="항해플러스 커리큘럼" caption="항해플러스 커리큘럼" />

항해플러스에서 어느덧 테스트코드에 대해 배우게 되는 챕터가 되었다.

항해를 최대한 열심히 소화하려고 하고 있지만, 이번 주에는 건강적인 문제와 회사일로 인해 바빴던 터라.. 제대로 과제를 수행하지 못하였다.

정말 깊게 배우고 싶었던 분야였고, 어찌되었든 언젠가는 배워야하는 분야이기에, 이번 기회에 제대로 이해하고자 글을 적게 되었다.

## 테스트란?

<Figure fileName="v_diagram.webp" alt="V Diagram" caption="V Diagram" />

일상생활에서 말하는 `테스트`라는 용어와 같은 맥락으로 사용된다.

소프트웨어가 잘 돌아가는 지 검증하기 위한 작업이며, 보안이나 오류 등 소프트웨어의 품질을 검증하는 작업을 말한다.

그리고, 소프트웨어 테스팅을 하기 위해 작성한 테스트 프로그램을 흔히 `테스트 코드`라고 부른다.

## 테스트의 중요성

> 아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직하다. 사람은 실수하기 마련이다. 적어도 내가 겪은 바로는 그렇다. 한 가지를 수정할 때마다 테스트 하면, 오류가 생기더라도 변경 폭이 작기 떄문에 살펴볼 범위도 좁아서 문제를 찾고 해결하기가 훨씬 쉽다. 이처럼 조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차에 핵심이다. 한 번에 너무 많이 수정하려다 실수를 저지르면 디버깅하기 어려워서 결과적으로 작업 시간이 늘어난다. 조금씩 수정하여 피드백 주기를 짧게 가져가는 습관이 이러한 재앙을 피하는 길이다.

`Clean code`의 저자 로버트 C. 마틴은 테스트를 단순히 버그를 찾는 도구 이상의, 소프트웨어 품질과 유지보수성을 보장하는 핵심 요소로 다루고 있다.

테스트코드는 크게 2가지 이유에서 생각해볼 수 있다.

- 안전망 역할: 테스트는 코드를 변경하거나 리팩토링할 때 기존 기능이 깨지지 않도록 하는 일종의 안전망 역할을 한다.
- 피드백 루프: 빠른 피드백을 통해 코드가 의도한 대로 동작하는지를 지속적으로 확인할 수 있으므로, 문제를 초기에 발견하고 수정할 수 있다.

## 테스트 코드가 작성될 때의 효과

| 효과                        | 설명                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 코드 품질 보증              | - 안정성 : 테스트를 통해 코드가 예상대로 동작하는지 확인함으로써, 안정적인 소프트웨어를 개발할 수 있다.<br/><br/>- 신뢰성: 변경 사항이 기존 기능에 미치는 영향을 빠르게 파악할 수 있어, 리팩토링이나 새로운 기능 추가 시에도 안정성을 유지할 수 있다.                                                                                                                                                                                                                                                                                                                          |
| 버그 조기 발견 및 수정      | - 문제의 조기 발견: 개발 초기 단계에서 테스트를 진행하면, 나중에 발견하기 어려운 문제들을 미리 찾을 수 있다.<br/><br/>- 비용 절감: 버그를 사전에 찾아내고 수정함으로써, 나중에 발생할 수 있는 큰 문제(예: 시스템 다운타임, 사용자 불만 등)를 방지할 수 있다.                                                                                                                                                                                                                                                                                                                   |
| 개발 속도 및 생산성 향상    | - 자동화 테스트: 반복적인 수동 테스트를 자동화하면, 테스트 수행에 드는 시간을 줄이고 개발 주기를 단축할 수 있다.<br/><br/>- 리팩토링 지원: 테스트가 존재하면 코드 수정 후에도 기존 기능이 정상 동작하는지 빠르게 확인할 수 있어, 리팩토링을 안전하게 진행할 수 있다.                                                                                                                                                                                                                                                                                                           |
| 문서화 및 커뮤니케이션 도구 | - 코드 사용법 명세: 테스트 코드는 함수나 모듈이 어떤 입력에 대해 어떤 출력을 내는지 명확히 보여주므로, 문서 역할을 한다.<br/><br/>- 협업 도구: 여러 개발자가 협업할 때, 테스트를 통해 각자 작성한 코드의 동작을 보장할 수 있다.                                                                                                                                                                                                                                                                                                                                                |
| 좋은 설계를 유도            | - 테스트 가능한 코드 = 좋은 코드: 테스트하기 어려운 코드는 보통 결합도가 높거나, 단일 책임 원칙(SRP)을 위반하고 있을 가능성이 크다. 테스트를 염두에 두고 개발하면, 모듈화가 잘 되어 있고, 의존성이 낮으며, 재사용성이 높은 코드를 만들 수 있다.<br/><br/>- 디커플링(Decoupling) 촉진: 테스트를 쉽게 만들기 위해서는 의존성이 적은 구조가 필요하며, 자연스럽게 의존성 주입(DI, Dependency Injection)과 같은 좋은 설계 패턴이 도입된다.<br/><br/>- 명확한 인터페이스: 테스트 코드 작성 시, 모듈 간의 경계를 더 명확하게 정의하게 되며, 이는 API 설계에도 긍정적인 영향을 미친다. |

테스트코드 작성에 있어서 추가적인 리소스를 요구함에도 불구하고, 작성을 해야하는 이유 중 하나는 위와 같은 효과들이다.

사실, 개발 과정에서 내가 짠 코드든, 남이 짠 코드든 시간이 지남에 따라 레거시화가 되어, 알아보기 어려운 일이 생긴다.

그리고, 코드가 점점 복잡해지고, 기능이 추가되면서, 코드를 수정하거나 리팩토링을 할 때, 테스트 코드가 없다면, 코드가 제대로 동작하는지 확인하기 어려워진다.

코드는 새롭게 개발하는 것보다 유지보수를 하는 경우가 많다. 이 때에, 테스트 코드가 있으면 내가 짠 코드에 대한 사이드 이펙트를 확인하기 보다 쉬워져,

오히려 생산성이 증가하는 결과를 낳기 때문에, 작성을 적극 권장한다고 이해할 수 있다.

## 테스트를 작성하는 방식

소프트웨어 테스트 방식은 크게 2가지로 구분이 된다.

`명세 기반 테스트`와 `구현 기반 테스트`이다.

이 두 가지 방식은 테스트를 작성하는 기준이 <strong>"요구사항(명세)"</strong>를 따르는지, 아니면 <strong>"내부 구현(코드 구조)"</strong>를 따르는지에 따라 구분된다.

### 1. 명세 기반 테스트(Specification-Based Testing)

> 명세 기반 테스트는 `블랙박스 테스트(Black-box Testing)`라고도 부른다.

#### 개념

소프트웨어의 <strong>기능 요구사항(명세, Specification)</strong>을 기반으로 테스트 케이스를 작성하는 방식이다.

즉, 소프트웨어가 "어떻게 동작해야 하는가?"에 대한 명확한 정의(명세)를 기준으로 테스트를 수행하는 방식이다.

<strong>블랙박스 테스트(Black Box Testing)</strong>의 한 종류로, 내부 코드의 구현 방식에는 신경 쓰지 않고, 입력(input)과
출력(output) 간의 관계를 검증하는 데 집중한다.

#### 명세 기반 테스트의 핵심 원리

##### 1. 요구사항 분석

- "이 기능은 어떤 동작을 해야 하는가?"
- "입력 값이 주어지면 어떤 결과가 나와야 하는가?"
- "사용자가 기대하는 동작은 무엇인가?"

위와 같은 기준들을 고려하면서, 요구사항을 분석하고, 테스트 케이스를 작성한다.

때에 따라서는 `유저 스토리(User Story)`나 `요구사항 명세서`를 기반으로 테스트 케이스를 작성하기도 한다.

##### 2. 테스트 케이스 설계

명세서에서 정의한 동작을 만족하는지 확인하는 테스트 케이스를 작성한다.

##### 3. 독립적 검증

개발자가 아닌 QA(Test Engineer) 또는 비개발자(기획자, PM) 도 명세를 기준으로 테스트할 수 있다.

##### 4. 내부 로직을 고려하지 않음

코드가 어떻게 구현되었는지보다는, 요구사항을 올바르게 충족하는지를 테스트하는 것이 목적이다.

#### 특징

| 특징             | 설명                                                              |
| ---------------- | ----------------------------------------------------------------- |
| 요구사항 중심    | 사용자의 요구사항 및 제품 명세서를 기반으로 테스트                |
| 블랙박스 테스트  | 내부 코드 로직을 신경 쓰지 않음                                   |
| 독립적인 테스트  | 개발자가 아닌 QA 팀에서도 테스트 가능                             |
| 기능 검증에 집중 | "어떻게 구현되었는가?"보다는 "기능이 올바르게 동작하는가?"를 검증 |
| 자동화 가능      | 테스트 명세서를 기반으로 자동화 테스트 스크립트를 만들기 용이     |

#### 명세 기반 테스트의 종류

##### 1. 동등 분할 테스트 (Equivalence Partitioning)

입력 데이터를 몇 개의 그룹(동등 클래스)으로 나누어 대표 값을 테스트하는 기법이다.

같은 그룹 내에서는 같은 동작을 해야 한다고 가정하고, 각 그룹에서 최소한 하나의 테스트 케이스를 선정하여 실행한다.

<Tabs>

<TabItem value="예제" label="예제">

사용자가 나이를 입력하는 폼에서,

- 0~12세 → "어린이"
- 13~19세 → "청소년"
- 20세 이상 → "성인"

위와 같은 요소가 있다고 가정을 해보자.

```TypeScript
function getUserType(age: number): string {
  if (age >= 0 && age <= 12) return "어린이";
  if (age >= 13 && age <= 19) return "청소년";
  if (age >= 20) return "성인";
  throw new Error("잘못된 입력");
}
```

위와 같은 코드로 표현할 수 있다.

</TabItem>

<TabItem value="테스트 코드 작성" label="테스트 코드 작성">

```TypeScript

import {describe, it, exepct} from 'vitest';
import {getUserType} from './getUserType';

describe('getUserType', () => {
  it("0~12세는 '어린이'를 반환해야 한다.", () => {
    expect(getUserType(5)).toBe('어린이'); // 0~12세를 하나의 그룹으로 생각해서, 5라는 값을 넣어서 테스트
  })
  it ("13~19세는 '청소년'을 반환해야 한다.", () => {
    expect(getUserType(15)).toBe('청소년'); // 13~19세를 하나의 그룹으로 생각해서, 15라는 값을 넣어서 테스트
  });
  it ("20세 이상은 '성인'을 반환해야 한다.", () => {
    expect(getUserType(25)).toBe('성인'); // 20세 이상을 하나의 그룹으로 생각해서, 25라는 값을 넣어서 테스트
  });
});
```

위와 같은 방법을 바탕으로 그룹화를 시켜서 테스트를 진행할 수 있다.

</TabItem>

</Tabs>

##### 2. 경계값 분석 테스트 (Boundary Value Analysis)

입력의 경계(최소값, 최대값, 경계값 바로 앞뒤)를 테스트하는 기법이다.

버그가 가장 많이 발생하는 곳이 경계값이므로, 이를 집중적으로 테스트해야 한다.
